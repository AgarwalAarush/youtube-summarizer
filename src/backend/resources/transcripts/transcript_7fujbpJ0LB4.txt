hello and welcome my name is William and today we're moving on to talking about the depth first search algorithm which plays a central role in several graph theory algorithms so what is a depth-first search a depth-first search is a core algorithm in graph theory that allows you to explore nodes and edges of a graph so it's a form of traversal algorithm the nice thing about a depth-first search is that it's a really easy to code and it runs in a time complexity of Big O of V Plus E that is vertices plus edges which is directly proportional to the size of your graph by itself a depth-first search isn't all that useful but when argumented to perform other tasks such as count connected components determine connectivity between nodes or find bridges and articulation points the depth first search algorithm really shines so let's look at an example as the name suggests a depth-first search plunges depth-first into a graph with that regard for which edge it selects next until you cannot go any further at which point it backtracks and continues its exploration so a depth-first search has to start on a node and I'm going to start our depth first search on node zero and now we arbitrarily pick a node to go to some from node zero we're going to go to node 9 then from no nine we only have one choice which is to go to node 8 at node 8 arbitrarily pick an edge so we're going to go outwards to node seven no seven we have plenty of edges to choose from so let's go to node ten node ten to note eleven and eleven to seven so we don't want to revisit already visited nodes or nodes that are currently being visited so we have to backtrack to indicate backtracking I'm going to label edges and nodes as gray so backtrack all the way back to node 7 so we're not finished exploring node 7 because there are still edges to be picked so I'm going to go to node 3 I know that 3 I'm gonna go node 2 node 2 is a dead end so we backtrack then go to node 4 node 4 is also a dead end so backtrack from node 4 back to node 3 then pick node 3 s last edge to go node 5 5 to 6 and 6 to 7 can't go to 7 because we're visiting 7 currently so backtrack all the way back to node 8 from node 8 we still need to visit its last edge which goes to node 1 node 1 back to node 0 we can't go and node 0 because we're currently exploring it then backtrack all the way to 0 which completes our depth first search traversal of this graph so this was one particular depth-first search traversal but as you saw it could have gone a lot of different ways so now let's look at some pseudocode for this depth-first search to get a deeper understanding of how it works the first thing we'll need to do is initialize these three variables which are n the number of nodes in our graph G the adjacency list representing the graph and visited a boolean array containing true or false at index I depending on whether or not node I has been visited in the beginning this array should have all false values because we have not visited any nodes in the graph once that is set up at the bottom I define our starting node to be node 0 and then called the depth-first search method to do the exploration the depth-first search itself has one argument the current node you're at which I have conveniently named at this method is recursive so I check the base case which is whether we have already visited this node if so we have no business here and can return otherwise let's visit this node by marking it as true and exploring all of its neighbors to explore all the neighbors of the node reach into the adjacency list and pull out all the neighbors of this node and explore them depth first by looping over each and recursively calling the depth-first search method and that's all a depth-first search really is in a nutshell let's look at another simple use case for a depth-first search I want to discuss finding connected components in a graph first let's understand what we mean by connected component sometimes the graph is split into multiple disjoint components and it's useful to be able to identify and count these components one way to identify these components might be to color them so we can tell them apart but what does colouring nodes really mean to a computer coloring nodes is equivalent to labeling each node in a component with the same ID value for example every node and the purple component gets an idea of one and every node in the green component gets an ID of three we can use a depth-first search to identify a components this way first make sure all the nodes are labeled from 0 to n non-inclusive where n is the number of nodes the basic algorithm is to start a depth-first search at every node except if that node has already been visited and mark all reachable nodes as being part of the same component using the same ID so if we start at node 0 then we do a depth first search here and then every node in this component gets an ID of 0 so go to 8 giving it an idea of 0 14 gets 0 13 also label it with a 0 then backtrack like you do a depth first search then explore note for given an ID of zero and then finish exploring that component and then move on to the next node in order so go to node one next then node one sorry depth first search there so go node five label it with a 1 5 goes to 17 label it with a 1 backtrack go to 16 also label it with a 1 we're finished exploring this component then we would go on to node 2 wherever node 2 is then explore that component then node 3 explore node 3 component unless node 3 has already been visited and so on so you do this for every component and eventually we get to label all the components and we used a depth-first search to do that awesome so that's how we find connected components using a depth-first search now let's look at some pseudocode for how we do this first we'll need a couple of things we'll need everything from the previous code we looked at so N and the number of nodes in our graph G our adjacency list and our visited array but additionally we'll also need a variable called count that tracks the number of connected components and components an integer array that holds the integer value of which component a node belongs to inside the fine components method we loop over every node and check if the current node has been visited or not and then execute some logic this death first search variant differs slightly from the previous in that we execute a depth-first search for every unvisited note when we actually do the depth-first search we visit nodes and mark them as visited so we never revisit the same node more than once we either skip over a node because it's been visited in this for loop or start a depth-first search there if we start a new depth-first search we increment the count variable and keep track of how many depth-first searches we have done inside the depth-first search method itself the two things we do are mark the current node as visited and set the current node to be part of the component equal to the value of count and then simply iterate over every neighboring node that has not yet been visited and call the depth-first search method to explore them as well back inside the find components method simply return the number of components and the components array that contains the information about which component each node belongs to so we've covered two of the things you can use a depth-first search for doing a simple traversal and determining connected components but we can augment a depth-first search to do so much more such as computer graphs minimum spanning tree detect and find cycles in the graph check if our graph is bipartite find strongly connected components topologically sort your graph find bridges and articulation points find augmenting paths in the flow Network generate mazes and many many more applications so a depth-first search is super versatile and can be extended to do a whole ton of things thank you for watching next video I should be talking about the breadth-first search algorithm stay tuned and subscribe for more mathematics and computer science videos Cheers 